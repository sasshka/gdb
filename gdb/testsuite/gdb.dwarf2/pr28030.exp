# Copyright 2018-2021 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

load_lib dwarf.exp

# This test can only be run on targets which support DWARF-2 and use gas.
if ![dwarf2_support] {
    return 0
}

# We'll place the output of Dwarf::assemble in pr28030.S.
standard_testfile .c .S

# ${testfile} is now "pr28030".  srcfile2 is "pr28030.S".
set executable ${testfile}
set asm_file [standard_output_file ${srcfile2}]

# We need to know the size of integer and address types in order
# to write some of the debugging info we'd like to generate.
#
# For that, we ask GDB by debugging our pr28030 program.
# Any program would do, but since we already have pr28030
# specifically for this testcase, might as well use that.
if [prepare_for_testing "failed to prepare" ${testfile} ${srcfile}] {
    return -1
}
set int_size [get_sizeof "int" -1]
# gdb always assumes references are implemented as pointers.
set addr_size [get_sizeof "void *" -1]

# Create the DWARF.  
Dwarf::assemble ${asm_file} {
    global int_size addr_size

    cu {} {
        DW_TAG_compile_unit {
    	{DW_AT_language @DW_LANG_C_plus_plus}
        } {
    	declare_labels int_label class_A_label class_B_label
 
        int_label: DW_TAG_base_type {
            {DW_AT_byte_size ${int_size} DW_FORM_udata}
            {DW_AT_encoding @DW_ATE_signed}
            {DW_AT_name "int"}
	}

    	class_A_label: DW_TAG_class_type {
    	    {DW_AT_byte_size 8*$int_size DW_FORM_sdata}
    	} {
    	    DW_TAG_member {
    		{DW_AT_name "a"}
    		{DW_AT_type :$int_label}
    		{DW_AT_data_member_location 0*$int_size DW_FORM_udata}
    	    }
    	    DW_TAG_member {
    		{DW_AT_name "x"}
    		{DW_AT_type :$int_label}
    		{DW_AT_data_member_location 1*$int_size DW_FORM_udata}
    	    }
    	}

    	class_B_label: DW_TAG_class_type {
    	    {DW_AT_byte_size 8*$int_size DW_FORM_sdata}
    	} {
    	    DW_TAG_member {
    		{DW_AT_name "a"}
    		{DW_AT_type :$int_label}
    		{DW_AT_data_member_location 2*$int_size DW_FORM_udata}
    	    }
    	    DW_TAG_member {
    		{DW_AT_name "x"}
    		{DW_AT_type :$int_label}
    		{DW_AT_data_member_location 3*$int_size DW_FORM_udata}
    	    }
    	    DW_TAG_inheritance {
    		{DW_AT_type :$int_label}
    		{DW_AT_data_member_location 4*$int_size DW_FORM_udata}
    	    }
    	}

    	DW_TAG_subprogram {
    	    {MACRO_AT_func { "main" }}
    	    {DW_AT_type :${int_label}}
    	    {DW_AT_external 1 DW_FORM_flag}
    	} {
    	}
        }
    }
}

if [prepare_for_testing "failed to prepare" ${executable} [list ${asm_file} ${srcfile}] {}] {
    return -1
}

# DW_OP_GNU_variable_value implementation requires a valid frame.
if ![runto_main] {
    return -1
}

gdb_test "print var_a" "= 8"

# DW_OP_GNU_variable_value implementation requires a valid frame.
if ![runto_main] {
    return -1
}
